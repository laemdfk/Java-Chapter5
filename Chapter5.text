<Java における型の種類>
大別して、「プリミティブ型(基本型)」と「参照型(クラス型)」の２種類がある。

1 プリミティブ型(基本型)
プリミティブ型は、「数値や文字のデータそのもの」を保持している型。Java のプリミティブ型は以下の８種類。

型名   型分類   サイズ（bit） 初期値                          値
----------------------------------------------------------------------------------
long   整数        64        0L       -9223372036854775808 ～ 9223372036854775807
----------------------------------------------------------------------------------
int    整数        32        0             -2147483648 ～ 2147483647
----------------------------------------------------------------------------------
short  整数        16        0                       -32768 ～ 32767
----------------------------------------------------------------------------------
byte   整数         8        0                          -128 ～ 127
----------------------------------------------------------------------------------
double 浮動小数     64       0.0d                   倍精度浮動小数点数
----------------------------------------------------------------------------------
float  浮動小数     32       0.0f                   単精度浮動小数点数
----------------------------------------------------------------------------------
boolean 論理        1      false                     true / false
----------------------------------------------------------------------------------
char    文字       16     \u0000              Unicode の一文字(¥u0000 ～ ¥uFFFF)
----------------------------------------------------------------------------------


<特徴>
1.整数型
整数を扱う型は、数値の大きさに合わせて４種類あり。通常は「int」型を使用する。
大きい数値を扱う場合には「long」型を使う。

プログラム上の整数値は「int」型として扱われる。
そのため「int」型の範囲外の整数をプログラムに記述する場合は、数値の最後に「L」または「l(小文字のエル)」を付けて、「long」型であること明示的に記述をする必要がある。
※ただし、「l(小文字のエル)」は「I(大文字のアイ)」や「1(数字のイチ)」と区別がつきづらいため、一般的には「L」を使用する。

(コードの例)
long long1 = 9223372036854775807;  // コンパイルエラーになる
long long2 = 9223372036854775807L;
※「short」型、「byte」型は明示的な記述をする必要はない

short short1 = 32767;
byte byte1 = 127;


2.浮動小数型
小数を扱う型は、数値の大きさに合わせて２種類あり、通常は「double」型を使用する。
プログラム上の小数値は「double」型として扱われる。
明示的に「float」型を宣言する場合は、数値の最後に「F」または「f」を付ける必要がある。
ただし、「double」型も「D」または「d」を付けて明示的にすることも可能。

(コードの例)
double double1 = 1234567.89;
double double2 = 1234567.89d;  // 明示的にすることも可能
float float1 = 0.123;          // コンパイルエラー
float float2 = 0.123f;


3.論理型
論理型を扱う型は、「boolean」型の１種類のみ。
格納できる値は、真偽値の「true」と「false」の2つだけ(Railsのboolean型と同じイメージ)。
プログラム上の真偽値は「boolean」型として扱われる。
「true」は真偽の「真」を表し、「OK」「YES」などの肯定的な意味を、「false」は真偽の「偽」を表し、「NG」「NO」などの否定的な意味を持つ。

(コードの例)
boolean boolean1 = true;
boolean boolean2 = false;


4.文字型
文字を扱う型は、「char」型の１種類のみ。
１つの変数に格納できるのは、１文字だけ
。一般的な文字だけでなく、文字コードで値を格納することが可能。
一般的な文字をプログラム上に記述する場合は、「'」(シングルクォーテーション)で囲む必要がある。
プログラム上の文字は「char」型として扱われる。

(コードの例)
char char1 = 'あ';
char char3 = 'A';
char char2 = 'AB'     // コンパイルエラー
char char4 = 0x3042;  // 文字コードでひらがなの「あ」を表現
'あ';                 // プログラム上ではchar型として扱われる


2 参照型(クラス型)
参照型は、(プリミティブ型とは異なり)データそのものを扱うのではなく、データがある「参照先」を保持する型。
※仮定
参照型とプリミティブ型の違い。
→→プリミティブ型が「生徒」の情報を持っているとしたら、参照型は「その生徒が所属するクラス」を保持するイメージ？


参照型の初期値は必ず「null」
※null = 参照型変数の中身が何もないことを表現する特別な値

ここで必要になるのが「ラッパークラス」

<ラッパークラス>
ラッパークラス = プリミティブ型を参照型として扱えるようにできるクラス

(ラッパークラス)
----------------------------
プリミティブ型	ラッパークラス型
----------------------------
long	            Long
----------------------------
int	             Integer
----------------------------
short           	Short
----------------------------
byte	            Byte
----------------------------
double	         Double
----------------------------
float	            Float
----------------------------
boolean          Boolean
----------------------------
char	          Character
----------------------------

(ボクシングとアンボクシング)
ボクシング = プリミティブ型の値をラッパークラス型へ変換すること
アンボクシング = ラッパークラス型の値からプリミティブ型へ変換すること

※ただし、ボクシング・アンボクシングには注意が必要
何度も変換を繰り返すとプログラムの速度が落ちてしまうため、使い所を見極める必要あり。
「自動で変換されるからどちらの型で定義しても良い」という考えではなく、適切な型を選ぶ習慣を。

また、ラッパークラス型の値はnullとなることがあるのに対し、「プリミティブ型はnullを許容しない」。
nullをアンボクシングするとNullPointerException(通称:ぬるぽ)が発生するので注意。


4 配列
配列 = 同じ型の複数のデータを１つの変数で扱えるようにしたも。
プリミティブ型だけでなくStringなど参照型のデータも持つことが可能。


要素 = 配列内のデータのこと。
各要素へのデータの代入や参照は、インデックス番号を使用して行う。
インデックス番号は０から始まり配列サイズから１引いた番号までになる。
※インデックス番号は1番ではなく0番から始まるので注意。

配列を生成するには、要素数を指定する必要があるが、生成した配列はサイズの変更ができない。

(コードの例)
int[] array1 = new int[3];  // 配列の宣言と生成
array1[0] = 60;  // インデックス番号「0」を指定して１番目の要素にデータを代入
array1[2] = 20;  // ２番目の要素より先に３番目の要素にデータを代入
array1[1] = 20;  // ３番目と同じ値を２番目の要素に代入
int int2 = array1[2];  // インデックス番号「2」を指定して３番目の要素を取得

int array2[] = null;  // []は変数名の後ろでも可
変数と同じように宣言と同時に初期化することも可能。形式は以下の２つ。

int[] array3 = new int[] { 10, 20, 50 };
int[] array4 = { 10, 20, 50 };


